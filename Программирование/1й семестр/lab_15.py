# Цель: создать программу, определяющую значение корня функции
# Переменные:
# x0 - начальное значение x
# hx - шаг, с которым изменяется x
# xn - конечное значение x
# a, b - границы, на которых ищется корень функции, a < b
# m - минимальное значение функции на отрезке [a, b]
# M - максимальное значение функции на отрезке [a, b]
# x - промежуточное значение х
# N - количество итераций в цикле
# eps - значение эпсилон
# r - переменная, отвечающая за выбор метода нахождения корня функции
# z - переменная, равная среднему значению на промежутке [a, b](Метод половинного деления)
# error - переменная, отвечающая за выполнимость условия(Метод Ньютона)
# h - отношение значения функции к её второй производной(Метод Ньютона)
# q, t - значение функции в точках a и b(Метод хорд)
# n - начальное значение x(Метод хорд)
# f1, f2 - значение функции в x и x + eps(Метод прямого вычисления)
# x1 - действующее значение переменной x(Метод итераций)
# Программисты: Барышев Г.А., Вендин А.С., Грачёв А.В., Гусев И.Б., Гуськов А.С.
# Дата написания: 18.11.2023
from math import e, log, sqrt

# Подпрограммы пользователя
def f(x):
    return e ** (3 * x / 2) - 2 * (x + 1) ** 2


def phi1(x):
    return 2 * log(2 * (x + 1) ** 2 / 3)


def phi2(x):
    return sqrt((e ** (3 * x / 2)) / 2) - 1

def phi3(x):
    return -1*sqrt((e**(3*x/2))/2) - 1


def funk_pr1(x):
    return (3 * e ** (3 * x / 2)) / 2 - 4 * (x + 1)


def funk_pr2(x):
    return (9 * e ** (3 * x / 2)) / 4 - 4


# ПЕРВЫЙ ЭТАП
# Блок ввода
x0 = float(input("Введите значение x0: "))
hx = float(input("Введите значение hx: "))
xn = float(input("Введите значение xn: "))

# Блок проверки
if (x0 < xn and hx < 0) or (x0 > xn and hx > 0):
    print("Неверно введённые данные")
    exit(1)

# Подготовка цикла
a = x0
b = x0 + hx

# Цикл и сопряжённые блоки
while f(a) * f(b) > 0 and b < xn + hx / 2:
    a += hx
    b += hx

if b < xn + hx / 2:
    print("Левая граница: ", a, ", правая граница: ", b)
else:
    print("В данном диапазоне нет нулей")
    exit()

# ВТОРОЙ ЭТАП
# Блок ввода
N = 0
eps = 1e-5
print("Выберите метод, которым хотите вычислить корень функции: ")
print("1. Метод итераций")
print("2. Метод половинного деления")
print("3. Метод Ньютона")
print("4. Метод хорд")
print("5. Метод прямого вычисления функции")
r = int(input("Введите номер метода: "))

match r:
    case 1:  # Метод итераций
        x = (a + b) / 2
        while True:
            if x > 0:
                x1 = phi1(x)
            elif x > -1:
                x1 = phi2(x)
            else:
                x1 = phi3(x)
            d = abs(x1 - x)
            x = x1
            if x1 < eps:
                break
            N += 1
            print(f'Значение функции на шаге {N} = {f(x)}')
            print(f'Значение аргумента на шаге {N} = {x}')
            print()
        print(f'Количество итераций: {N} при точности {eps}')
        print(f'Приближённое значение аргумента равно {x}, f(x) = {f(x)}')
    case 2:  # Метод половинного деления
        while abs(b - a) >= eps:
           z = (a + b) / 2
           if f(z) * f(a) < 0:
              b = z
           else:
              a = z
           N += 1
           x = (a + b) / 2
           print(f'Значение функции на шаге {N} = {f(x)}')
           print(f'Значение аргумента на шаге {N} = {x}')
           print()
        print(f'Количество итераций: {N} при точности {eps}')
        print(f'Приближённое значение аргумента равно {x}, f(x) = {f(x)}')
    case 3:  # Метод Ньютона
        error = False
        if f(a) * funk_pr2(a) > 0:
           x = a
        elif f(b) * funk_pr2(b) > 0:
           x = b
        else:
           print("Ошибка")
           error = True

        if not error:
            while True:
                N += 1
                h = f(x) / funk_pr1(x)
                x = x - h
                print(f'Значение функции на шаге {N} = {f(x)}')
                print(f'Значение аргумента на шаге {N} = {x}')
                print()
                if abs(h) < eps:
                    print(f'Количество итераций: {N} при точности {eps}')
                    print(f'Приближённое значение аргумента равно {x}, f(x) = {f(x)}')
                    break
    case 4:  # Метод хорд
        q = f(a)
        t = f(b)
        x = a
        while True:
            N += 1
            x = a - ((b - a) * q / (t - q))
            y = f(x)
            if y * q < 0:
                b = x
                t = y
            else:
                a = x
                q = y

            print(f'Значение функции на шаге {N} = {f(x)}')
            print(f'Значение аргумента на шаге {N} = {x}')
            print()

            if abs(f(x)) <= eps:
                print(f'Количество итераций: {N}')
                print(f'Приближённое значение аргумента равно {x}, f(x) = {f(x)}')
                break
    case 5:  # Прямой ход
        x = a
        while x < b + eps / 2:
            f1 = f(x)
            f2 = f(x + eps)
            x += eps
            N += 1
            if N % 5000 == 0 or N > 22766:
                print(f'Значение функции на шаге {N} = {f(x)}')
                print(f'Значение аргумента на шаге {N} = {x}')
                print()
            if f1 * f2 <= 0:
                print(f'Количество итераций: {N} при точности {eps}')
                print(f'Приближённое значение аргумента равно {x}, f(x) = {f(x)}')
                break
    case _:
        print("Неверно введённое значение")
        exit()
