# Проект по дисциплине "Основы систем ИИ"
# Модель: Робот в лабиринте
# Программист: Барышев Григорий Александрович
# Дата начала работы: 02.09.2024
# Группа: 3413
from functools import cmp_to_key

p = [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2], [3, 2], [3, 3], [3, 4], [2, 4]]
# Добавленные библиотеки
from time import sleep
from collections import deque

# Перечень добавленных символов
chr(9608) # квадрат (для отображения стенок)

# Класс ситуации
class Situation:
    def __init__(self, m, c, g):
        self.maze = m # Действующий лабиринт (матрица)
        self.coords = c # Координаты робота (массив из двух координат)
        self.goal = g # Целевая координата (массив из двух координат)
        self.path = []
        self.cur_move = 0

    # Проверка целевой ситуации
    # Вход: ситуация
    # Выход: является ли ситуация целевой
    def goal_method(self, arr):
        a, b = arr[0], arr[1]
        if a == self.goal[0] and b == self.goal[1]:
            return True
        return False

    # Отображение ситуации
    # Вход: ситуация
    # Выход: отображение ситуации в консоли
    def show_method(self, arr):
        m = self.maze # Запись из ситуации лабиринта
        n1 = len(m) # Длина лабиринта
        n2 = len(m[0]) # Ширина лабиринта

        for i in range(n1):
            for j in range(n2):
                if [i, j] == arr: # Проверка координаты на координаты робота
                    print("R", end=" ")
                elif [i, j] in self.path:
                    print("1", end=" ")
                elif self.maze[i][j] == "2": # Проверка координаты на стенку
                    print(chr(9608), end=" ")
                elif [i, j] == self.goal: # Проверка координаты на цель
                    print("x", end=" ")
                else: # Вывод в остальных случаях
                    print(self.maze[i][j], end=" ")
            print()
        print()

    # Процедура определения тупика / стенки
    # Вход: ситуация
    # Выход: булева переменная, говорящая о том, тупик или нет
    def deadend_method(self, arr):
        # Проверка на то, является ли нынешняя координата стенкой
        if self.maze[arr[0]][arr[1]] == "2":
            return True # Да, стенка
        return False # Нет, не стенка

    def show_answer_method(self):
        global p
        print("Пройденный путь: ")
        print(p)
        print("Отображение пути: ")
        for i in range(len(self.maze)):
            for j in range(len(self.maze[0])):
                if [i, j] in p:
                    print("1", end=" ")
                elif self.maze[i][j] == "2":  # Проверка координаты на стенку
                    print(chr(9608), end=" ")
                elif [i, j] == self.goal:  # Проверка координаты на цель
                    print("x", end=" ")
                else:  # Вывод в остальных случаях
                    print(self.maze[i][j], end=" ")
            print()
        print()

    # Порождающая функция
    # Вход: ситуация, номер хода (0 <= n <= 3))
    # Промежуточные данные:
    # * vars - возможные ходы
    # Выход: новый ход
    def generate_method(self, arr):
        i, j = arr[0], arr[1]
        vars = []
        for el in [i, j + 1], [i + 1, j], [i - 1, j], [i, j - 1]:
            if el[0] < 0 or el[0] > 9 or el[1] < 0 or el[1] > 9 or self.deadend_method([el[0], el[1]]):
                continue
            else:
                vars.append(el) # добавление в вариации ходов нового хода

        # Возвращение всех возможны ходов
        return vars

    # Оценочная функция по градиенту
    # Вход: две ситуации (предыдущая и нынешняя)
    # Выход: -1, если ситуация стала хуже, 1, если лучше
    def gradient_estimate_method(self, sit1, sit2):
        if (sit1[0] - self.goal[0]) ** 2 + (sit1[1] - self.goal[1]) ** 2 <= (sit2[0] - self.goal[0]) ** 2 + (sit2[1] - self.goal[1]) ** 2:
            return -1
        else:
            return 1

    # Метод поиска решения для BFS
    # Вход: дерево ситуаций
    # Выход: путь, который проделал робот при достижении цели
    def found_solution_method(self, res_sol):
        step = self.goal                                    # начальная ситуация - целевая
        p = []                                              # инициализация пути
        while step is not None:                             # пока данная ситуация не None
            p.append(step)                                  # добавление в путь ситуацию
            step = res_sol[tuple(step)]                     # новая ситуация - это ключ в словаре
        p = p[::-1]                                         # реверсирование пути

        # Вывод
        print("Путь: ")
        print(p)
        m = self.maze  # Запись из ситуации лабиринта
        n1 = len(m)  # Длина лабиринта
        n2 = len(m[0])  # Ширина лабиринта

        for i in range(n1):
            for j in range(n2):
                if tuple([i, j]) in p:      # Если ситуация в пути
                    print("1", end=" ")
                elif self.maze[i][j] == "2":  # Проверка координаты на стенку
                    print(chr(9608), end=" ")
                elif [i, j] == self.goal:  # Проверка координаты на цель
                    print("x", end=" ")
                else:  # Вывод в остальных случаях
                    print(self.maze[i][j], end=" ")
            print()
        print()


    # -------------------- МЕТОДЫ -------------------- #

    # Метод поиска в глубину
    # Вход: начальная ситуация
    # Промежуточные данные:
    # * stack - стэк со всеми ситуациями на пути
    # * success - булева переменная, отвечающая за то, является ли нынешняя ситуация целевой
    # * new_sit - новая порождаемая ситуация
    # Выход: путь, который проделал робот при достижении цели
    def dfs_method(self):
        stack = [[self.coords, [0]]] # стэк для хранения ситуаций
        # Цикл по поиску, пока стэк не пустой
        while stack:
            success = self.goal_method(stack[-1][0]) # Проверка на достижение цели
            self.show_method(stack[-1][0])           # Отображение лабиринта, робота и цели
            sleep(0.5) # Функция для задержки вывода значений на экран

            if success: # Если достигнута цель
                for i in range(len(stack)):
                    self.path.append(stack[i][0]) # Добавление элементов стэка в path
                print("Пройденный путь: ")
                print(self.path) # Вывод path на экран
                print("Отображение пути:")
                self.show_method(stack[-1][0]) # Отображение лабиринта с путём, который проделал робот
                return

            # Формирование новой ситуации
            new_sit = self.generate_method(stack[-1])
            print(new_sit)

            # Проверка на то, попадает ли новая ситуация на уже ранее заложенные в стэк ситуации
            if any(situation[0][0:2] == new_sit[0][0:2] for situation in stack):
                stack[-1][1][0] += 1
                continue

            # Если новых ходов более нет
            if len(new_sit) == 0:
                stack.pop()
                # Если стэк стал пустым
                if len(stack) == 0:
                    break
                stack[-1][1][0] += 1  # увеличиваем номер предыдущего хода на 1

            else:  # Если ходы есть
                stack.append(new_sit)

        print("Нет решения!") # В случае, если решение не найдено
        return

    # Метод поиска в ширину
    # Вход: начальная ситуация
    # Выход: путь, который проделал робот при достижении цели
    def bfs_method(self):
        available_path = deque()  # область памяти, содержащая направления, которые можно посетить
        available_path.append(self.coords) # добавление ситуации в область памяти
        self.path.append(self.coords) # добавление начальной ситуации в массив ситуаций, которые были посещены
        result_path = {tuple(self.coords): None} # выделяется память под каждую ветку дерева

        # Пока deque не пуст
        while available_path:
            success = self.goal_method(available_path[0]) # возвращаем в переменную success логический литерал, отвечающий за то, является ли ситуация целевой
            self.show_method(available_path[0]) # отображение расположения элементов
            #print(self.coords)
            sleep(0.5) # задержка во времени прохода программы для того, чтобы разглядеть ситуацию

            # Если цель достигнута
            if success:
                self.show_method(self.path[0])  # отображение расположения элементов
                self.found_solution_method(result_path)
                return # выход из функции

            new_moves = self.generate_method(available_path[0]) # генерация новых шагов
            for move in new_moves: # прохождение по всем новым шагам по отдельности
                if all(move != x for x in self.path):  # если шага не было в очереди
                    available_path.append(move) # добавление новой ситуации в путь
                    self.path.append(move)  # добавление шага в массив ситуаций
                    result_path[tuple(move)] = tuple(available_path[0]) # добавление шага в дерево

            available_path.popleft() # удалить использованную ситуацию

        # Если очередь опустела, и к тому же решение не найдено
        print("Нет решения!")
        return

    # Метод встречного пути
    # Вход: начальная ситуация
    # Выход: путь, который проделал робот при достижении цели
    def meeting_method(self):
        return 0

# Основная программа
if __name__ == '__main__':
    # Лабиринты
    # 0 - незанятые точки
    # 2 - стенки
    # Первый лабиринт
    maze1 = [["0", "2", "0", "0", "0", "2", "0", "2", "2", "2"],
            ["0", "2", "2", "2", "0", "2", "0", "0", "2", "0"],
            ["0", "0", "0", "2", "0", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "2", "2", "2", "0", "2", "2", "2", "0", "2"],
            ["2", "2", "0", "0", "0", "2", "0", "2", "0", "2"],
            ["0", "0", "0", "2", "2", "2", "0", "2", "0", "2"],
            ["0", "2", "2", "2", "0", "0", "0", "2", "0", "2"],
            ["0", "2", "0", "2", "0", "2", "2", "2", "0", "2"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"]]

    # Второй лабиринт
    maze2 = [["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["2", "2", "2", "2", "2", "2", "2", "2", "2", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "2", "0"],
            ["0", "2", "2", "2", "2", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "2", "0", "2", "0"],
            ["0", "2", "0", "2", "2", "0", "2", "0", "2", "0"],
            ["0", "2", "0", "2", "2", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "2", "0"],
            ["0", "2", "2", "2", "2", "2", "2", "2", "2", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"]]

    # Третий лабиринт
    maze3 = [ ["0", "2", "0", "0", "0", "2", "0", "2", "2", "2"],
            ["0", "2", "2", "2", "0", "2", "0", "0", "2", "0"],
            ["0", "0", "0", "2", "0", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "2", "2", "2", "0", "2", "2", "2", "0", "2"],
            ["2", "2", "0", "0", "0", "2", "0", "2", "0", "2"],
            ["0", "0", "0", "2", "2", "2", "0", "2", "0", "2"],
            ["0", "2", "2", "2", "0", "0", "0", "2", "0", "2"],
            ["0", "2", "0", "2", "0", "2", "2", "2", "0", "2"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"] ]

    # Основная программа
    # Выбор лабиринта пользователем
    print("Выберите лабиринт:")
    print("1. Первый лабиринт")
    print("2. Второй лабиринт")
    print("3. Третий лабиринт")
    choiceMap = int(input("Введите номер карты: "))

    # Установление ситуации
    # Выбор лабиринта
    match(choiceMap):
        case 1: # Лабиринт 1
            maze = maze1
            start_position = [0, 0]
            #target_position = [1, 9]
            target_position = [5, 4]

        case 2: # Лабиринт 2
            maze = maze2
            start_position = [0, 0]
            target_position = [5, 5]
            #target_position = [0, 9]
            #target_position = [9, 8]

        case 3: # Лабиринт 3
            maze = maze3
            start_position = [0, 0]
            target_position = [1, 9]

    # Определение ситуации. Запись данных в объект класса Situation
    sit = Situation(maze, start_position, target_position)

    # Запуск метода BFS
    sit.bfs_method()