# Проект по дисциплине "Основы систем ИИ"
# Модель: Робот в лабиринте
# Программист: Барышев Григорий Александрович
# Дата начала работы: 02.09.2024
# Группа: 3413

# Добавленные библиотеки
from time import sleep
from collections import deque
from functools import cmp_to_key

# Перечень добавленных символов
chr(9608) # квадрат (для отображения стенок)

# Класс ситуации
class Situation:
    def __init__(self, m, c, g):
        self.maze = m # Действующий лабиринт (матрица)
        self.coords = c # Координаты робота (массив из двух координат)
        self.goal = g # Целевая координата (массив из двух координат)
        self.path = []
        self.cur_move = 0

    # Проверка целевой ситуации
    # Вход: ситуация
    # Выход: является ли ситуация целевой
    def goal_method(self, arr):
        a, b = arr[0], arr[1]
        if a == self.goal[0] and b == self.goal[1]:
            return True
        return False

    # Отображение ситуации
    # Вход: ситуация
    # Выход: отображение ситуации в консоли
    def show_method(self, arr):
        m = self.maze # Запись из ситуации лабиринта
        n1 = len(m) # Длина лабиринта
        n2 = len(m[0]) # Ширина лабиринта

        for i in range(n1):
            for j in range(n2):
                if [i, j] == arr: # Проверка координаты на координаты робота
                    print("R", end=" ")
                elif [i, j] in self.path:
                    print("1", end=" ")
                elif self.maze[i][j] == "2": # Проверка координаты на стенку
                    print(chr(9608), end=" ")
                elif [i, j] == self.goal: # Проверка координаты на цель
                    print("x", end=" ")
                else: # Вывод в остальных случаях
                    print(self.maze[i][j], end=" ")
            print()
        print()

    # Процедура определения тупика / стенки
    # Вход: ситуация
    # Выход: булева переменная, говорящая о том, тупик или нет
    def deadend_method(self, arr):
        # Проверка на то, является ли нынешняя координата стенкой
        if self.maze[arr[0]][arr[1]] == "2":
            return True
        return False

    # Порождающая функция
    # Вход: ситуация, номер хода (0 <= n <= 3))
    # Промежуточные данные:
    # * vars - возможные ходы
    # Выход: новый ход
    def generate_method(self, arr):
        i, j, n = arr[0][0], arr[0][1], arr[1][0]
        vars = []
        for el in [[i, j + 1], [0]], [[i + 1, j], [0]], [[i - 1, j], [0]], [[i, j - 1], [0]]:
            if el[0][0] < 0 or el[0][0] > 9 or el[0][1] < 0 or el[0][1] > 9 or self.deadend_method([el[0][0], el[0][1]]):
                continue
            else:
                vars.append(el) # добавление в вариации ходов нового хода

        # Сортировка возможных ходов по ключу в зависимости от того, насколько сильно ситуация отличается от целевой
        vars.sort(key=cmp_to_key(self.valuation_method))
        # Проверка номера хода на размер
        if n < len(vars):
            return vars[n]
        else:
            return [] # Нового шага нет

    # Оценочная функция по градиенту
    # Производит сравнение ситуаций
    # Вход: набор ситуаций
    # Выход: -1, если ситуация стала хуже, 1, если лучше или та же
    def valuation_method(self, *sits):
        sit1, sit2 = sits[0], sits[1]
        # Сравнение ситуаций с целевой
        if (sit1[0][0] - self.goal[0]) ** 2 + (sit1[0][1] - self.goal[1]) ** 2 <= (sit2[0][0] - self.goal[0]) ** 2 + (sit2[0][1] - self.goal[1]) ** 2:
            return -1 # Если ситуация хуже
        else:
            return 1 # Если ситуация лучше или та же

    # -------------------- МЕТОДЫ -------------------- #

    # Метод поиска в глубину
    # Вход: начальная ситуация
    # Промежуточные данные:
    # * stack - стэк со всеми ситуациями на пути
    # * success - булева переменная, отвечающая за то, является ли нынешняя ситуация целевой
    # * new_sit - новая порождаемая ситуация
    # Выход: путь, который проделал робот при достижении цели
    def dfs_method(self):
        stack = [[self.coords, [0]]] # стэк для хранения ситуаций
        # Цикл по поиску, пока стэк не пустой
        while stack:
            success = self.goal_method(stack[-1][0]) # Проверка на достижение цели
            self.show_method(stack[-1][0])           # Отображение лабиринта, робота и цели
            sleep(0.5) # Функция для задержки вывода значений на экран

            if success: # Если достигнута цель
                for i in range(len(stack)):
                    self.path.append(stack[i][0]) # Добавление элементов стэка в path
                print("Пройденный путь: ")
                print(self.path) # Вывод path на экран
                print("Отображение пути:")
                self.show_method(stack[-1][0]) # Отображение лабиринта с путём, который проделал робот
                return

            # Формирование новой ситуации
            new_sit = self.generate_method(stack[-1])
            print(new_sit)

            # Проверка на то, попадает ли новая ситуация на уже ранее заложенные в стэк ситуации
            if any(situation[0][0:2] == new_sit[0][0:2] for situation in stack):
                stack[-1][1][0] += 1
                continue

            # Если новых ходов более нет
            if len(new_sit) == 0:
                stack.pop()
                # Если стэк стал пустым
                if len(stack) == 0:
                    break
                stack[-1][1][0] += 1  # увеличиваем номер предыдущего хода на 1

            else:  # Если ходы есть
                stack.append(new_sit)

        print("Нет решения!") # В случае, если решение не найдено
        return

    # Метод поиска в ширину
    # Вход: начальная ситуация
    # Выход: путь, который проделал робот при достижении цели
    def bfs_method(self):
        path = deque()  # область памяти, содержащая направления, которые можно посетить
        path.append([[self.coords, [0]]])

        # Пока queue не пуст
        while path:
            success = self.goal_method(path[0])
            self.show_method(path[0])
            if success:
                self.path = path[0]
                print("Пройденный путь: ")
                print(self.path) # Вывод всего пути на экран
                return

            new_moves = self.generate_method(path[0])
            for move in new_moves:
                if all(move[0:2] != x[0:2] for x in path):  # если её не было в очереди
                    path.append(move)
                    self.cur_move += 1

            # Если очередь опустела, и к тому же решение не найдено
            return

# Основная программа
if __name__ == '__main__':
    # Лабиринты
    # 0 - незанятые точки
    # 2 - стенки
    # Первый лабиринт
    maze1 = [["0", "2", "0", "0", "0", "2", "0", "2", "2", "2"],
            ["0", "2", "2", "2", "0", "2", "0", "0", "2", "0"],
            ["0", "0", "0", "2", "0", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "2", "2", "2", "0", "2", "2", "2", "0", "2"],
            ["2", "2", "0", "0", "0", "2", "0", "2", "0", "2"],
            ["0", "0", "0", "2", "2", "2", "0", "2", "0", "2"],
            ["0", "2", "2", "2", "0", "0", "0", "2", "0", "2"],
            ["0", "2", "0", "2", "0", "2", "2", "2", "0", "2"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"]]

    # Второй лабиринт
    maze2 = [["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["2", "2", "2", "2", "2", "2", "2", "2", "2", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "2", "0"],
            ["0", "2", "2", "2", "2", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "2", "0", "2", "0"],
            ["0", "2", "0", "2", "2", "0", "2", "0", "2", "0"],
            ["0", "2", "0", "2", "2", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "2", "0"],
            ["0", "2", "2", "2", "2", "2", "2", "2", "2", "0"],
            ["0", "0", "0", "0", "0", "0", "0", "0", "0", "0"]]

    # Третий лабиринт
    maze3 = [ ["0", "2", "0", "0", "0", "2", "0", "2", "2", "2"],
            ["0", "2", "2", "2", "0", "2", "0", "0", "2", "0"],
            ["0", "0", "0", "2", "0", "2", "2", "0", "2", "0"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"],
            ["0", "2", "2", "2", "0", "2", "2", "2", "0", "2"],
            ["2", "2", "0", "0", "0", "2", "0", "2", "0", "2"],
            ["0", "0", "0", "2", "2", "2", "0", "2", "0", "2"],
            ["0", "2", "2", "2", "0", "0", "0", "2", "0", "2"],
            ["0", "2", "0", "2", "0", "2", "2", "2", "0", "2"],
            ["0", "2", "0", "0", "0", "0", "0", "0", "0", "0"] ]

    # Основная программа
    # Выбор лабиринта пользователем
    print("Выберите лабиринт:")
    print("1. Первый лабиринт")
    print("2. Второй лабиринт")
    print("3. Третий лабиринт")
    choiceMap = int(input("Введите номер карты: "))

    # Установление ситуации
    # Выбор лабиринта
    match(choiceMap):
        case 1: # Лабиринт 1
            maze = maze1
            start_position = [0, 0]
            #target_position = [1, 9]
            target_position = [2, 4]

        case 2: # Лабиринт 2
            maze = maze2
            start_position = [0, 0]
            target_position = [5, 5]
            #target_position = [0, 9]
            #target_position = [9, 8]

        case 3: # Лабиринт 3
            maze = maze3
            start_position = [0, 0]
            target_position = [1, 9]

    # Определение ситуации. Запись данных в объект класса Situation
    sit = Situation(maze, start_position, target_position)

    # Запуск метода DFS
    sit.dfs_method()